% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{State of the art}\label{chapter:state_of_the_art}
Despite having been around for a few decades, fuzzing has begun to gain a lot more popularity in recent years~\parencite{8371326}.
While the idea of fuzzing may appear simple at its core, there have been so many advancements that have enabled popular fuzzing
frameworks to implement some very interesting optimizations. Some of the main areas that these frameworks often focus
on improving are the following:

\begin{itemize}
    \item \textbf{Input generation}: This component is responsible for generating the input corpus that will be used to
    run the target application. The most basic form of input generation is to simply create random inputs. The next step
    in terms of complexity, is to use more complex algorithm-based approaches, such as bit or byte flipping. Finally,
    most performant fuzzers also take into account the structure of the input data, as well as leverage the knowledge
    provided by coverage data of the target.
    \item \textbf{Corpus management}: Any fuzzing campaign begins with an initial set of seed inputs, generally provided by the
    user. As the campaign progresses, and the fuzzer generates additional inputs, the corpus grows. This is where corpus
    management comes into play, as it falls to the fuzzer to decide which inputs to keep in the corpus, and which to discard.
    This is necessary in order to avoid wasting resources on inputs that are not likely to trigger new code paths, since otherwise
    the corpus would grow to huge sizes. Common heuristics of determining which inputs to keep are based on coverage data, or
    on the performance of the target application when processing the input, in terms of crashes, hangs, execution speed, etc.
    \item \textbf{Coverage data}: Keeping track of the code coverage achieved by target runs is a key component of any 
    modern fuzzer. Firstly, this info can provide the user with relevant statistics about the campaign. Secondly, coverage info
    is perhaps the most important factor in determining the quality of the inputs generated by the fuzzer. Coverage data can
    relate to basic block coverage, edge coverage, function coverage, etc. The goal of the fuzzer is to have reliable coverage
    tracking, while also keeping the overhead of this tracking to a minimum.
    \item \textbf{Instrumentation}: In order to collect coverage data, and to also add additional features like \ac{ASAN},
    the fuzzer needs to add some bits of code to the target, which perform the necessary operations. This is done either
    at compile time, by using special compilers~\parencite{8989335}, or at runtime, by using dynamic binary 
    instrumentation~\parencite{269899}.
\end{itemize}

In the following sections, an overview of some of the most popular fuzzing frameworks, AFL++ and LibAFL, will be provided.
These two frameworks have been chosen because they are well integrated with QEMU, and have solid implementations for the
\ac{QASAN} feature for binary-only fuzzing.


\section{AFL++}
AFL++ is a fork of the original \ac{AFL} coverage-guided fuzzer~\parencite{257204}. The main goal of AFL++ is to

\section{LibAFL}


\section{Current shortcomings}